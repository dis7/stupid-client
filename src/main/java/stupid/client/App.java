/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stupid.client;

import javax.net.SocketFactory;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

public class App {

    public static void main(String[] args) throws Exception {
        try (Socket client = SocketFactory.getDefault().createSocket(InetAddress.getLocalHost(), 8011)){
            OutputStream os = client.getOutputStream();

            String message = "GET /hello HTTP/1.1\r\nHost: localhost:8011\r\nUser-Agent: Java\r\nAccept: */*\r\n\r\n";
            System.out.println("About to send a message ");
            os.write(message.getBytes(StandardCharsets.UTF_8));
            os.flush();
            System.out.println("DONE SENDING");
            InputStream in = client.getInputStream();
//            parseResponse(in);
//            parseResponseV1(in);
            // This is the best implementation, conforming to HTTP best.
            parseResponseV2(in);

        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    // 1 minute till socket closes
    public static void parseResponse(InputStream in) throws IOException {
        int c;
        StringBuilder sb = new StringBuilder();
        while ((c = in.read()) != -1) {
            sb.append((char) c);
        }
        System.out.println("Received: " + sb.toString());
    }

    // Dumb way to do the parsing.
    public static void parseResponseV1(InputStream in) throws IOException {
        String protocolLine = "";
        boolean protocolLineDone = false;
        boolean quoteInLine = false;
        boolean isHeader = false;
        boolean foundCR = false;
        Map<String, String> headers = new HashMap<>();
        int bodyLength = -1;
        int counterForBody = -1;
        String body;

        int c;
        StringBuffer sb = new StringBuffer();
        while (true) {
            if (bodyLength != -1 && !isHeader) {
                if (bodyLength == counterForBody) {
                    body = sb.toString();
                    break;
                } else {
                    c = in.read();
                    if (c == 13) {
                        foundCR = true;
                        continue;
                    }
                    if (c == 10 && foundCR) {
                        foundCR = false;
                        continue;
                    }
                    counterForBody++;
                }
            } else {
                c = in.read();
            }
            if (c == 13) {
                foundCR = true;
                continue;
            }
            if (c == 10 && foundCR) {
                foundCR = false;
                if (!protocolLineDone) {
                    protocolLineDone = true;
                    protocolLine = sb.toString();
                    sb = new StringBuffer();
                }
                if (isHeader) {
                    String temp = sb.toString();
                    int endOfKeyIndex = temp.indexOf(':');
                    String key = temp.substring(0, endOfKeyIndex);
                    String val = temp.substring(endOfKeyIndex + 1);
                    headers.put(key, val);
                    sb = new StringBuffer();
                    if (bodyLength == -1) {
                        String contentLength = headers.get("Content-Length");
                        if (contentLength != null) {
                            bodyLength = Integer.parseInt(contentLength.trim());
                        }
                    }
                    counterForBody = 0;
                }
                quoteInLine = false;
                isHeader = false;
                continue;
            }
            if (c == 34) {
                quoteInLine = true;
            }
            if (c == 58) {
                isHeader = !quoteInLine;
            }
            sb.append((char) c);
        }
        System.out.println("ProtoLine: " + protocolLine);
        System.out.println("Headers: " + headers);
        System.out.println("Body: " + body);
        System.out.println();
    }

    public static void parseResponseV2(InputStream in) throws Exception {

        String protoLine = "";
        boolean protoLineFound = false;
        StringBuffer sb = new StringBuffer();
        Map<String, String> headers = new HashMap<>();
        String body;
        boolean foundCR = false;
        boolean prevNewLine = false;
        int bodyLength = -1;
        int bodyCurrentCount = 0;
        int c;

        while (true) {
            if (bodyLength != -1) {
                if (bodyCurrentCount == bodyLength) {
                    body = sb.toString();
                    break;
                }
                else {
                    sb.append((char)in.read());
                    bodyCurrentCount++;
                    continue;
                }
            }
            else {
                c = in.read();
            }
            if  (c == -1) {
                // Exception should be thrown in this unexpected closing of inputStream.
                throw new Exception("Why did inputStream get closed... ?  ");
            }
            if (c == 13) {
                foundCR = true;
                continue;
            }
            if (c == 10) {
                if (foundCR) {
                    foundCR = false;
                    if (!protoLineFound) {
                        protoLineFound = true;
                        protoLine = sb.toString();
                        sb = new StringBuffer();
                        continue;
                    }
                    if ( prevNewLine ) {
                        // there should always be a content-length header therefore, im not going to bother check for null
                        // if it's null then I deserve a fatal exception
                        bodyLength = Integer.parseInt(headers.get("Content-Length").trim());
                        continue;
                    }
                    String temp = sb.toString();
                    int endOfKeyIndex = temp.indexOf(':');
                    String key = temp.substring(0, endOfKeyIndex);
                    String val = temp.substring(endOfKeyIndex + 1);
                    headers.put(key, val);
                    sb = new StringBuffer();
                    prevNewLine = true;
                    continue;
                }
            }
            prevNewLine = false;
            sb.append((char) c);
        }
        System.out.println("ProtoLine: " + protoLine);
        System.out.println("Headers: " + headers);
        System.out.println("Body: " + body);
        System.out.println();

    }

}
